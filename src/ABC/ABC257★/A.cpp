#include <iostream>
using namespace std;
int main(void) {
  int n,x,a;
  cin >> n >> x;
  a = x % n == 0 ? x/n : x/n +1;
  cout << char(64 + a) << endl;
}
/**MEMO
 * 64(アスキーコードでAの前)から何番目かというカウントで、Aだったら＋1になるような計算だが、
 * Aから何番目かというほうがわかりやすい。64何だっけとなるし。
 * →そのためにはAから何番目か数える数える必要があり、(x-1)とし、x=1(1番目の値を求めたい＝Aから0番目)の時に0になるようにする。
 *
 * 元々、Aの一個前から何番目かという数え方なので、x/nが奇数の時に1足していた。例えばn=2 x=1(1番目の値を求めたい＝Aの一個前からから1番目)の時1/2＝0..1となり、本来求めたい値の-1になる。
 *
 * なぜx/nが奇数か偶数かを考慮する必要がなくなるのか
 * 整数除算の性質: 整数除算は結果を整数に丸め、余りを無視します。この性質を利用することで、x-1をnで割った結果が、Aからの正確なオフセット（距離）を示します。ここでのポイントは、除算の結果が奇数か偶数かというよりも、この操作がxがnのどの位置にあるか（つまりnの倍数のどのポイントに該当するか）を示すことです。
 *
 * 考慮するべき点
 * カウントの開始点: このアプローチの中心は、カウントを0から始める（Aを0番目とする）ことにより、x-1を使用することで、x=1の時にA（0番目）を正確に表現できるようにすることです。
 * 除算結果の利用: x-1をnで割った結果は、Aからの相対的な位置を直接示します。この結果は、xがnの何倍目に位置するかを示し、それに基づいてアルファベットの対応する文字を決定します。したがって、結果が奇数か偶数かは直接関係ありません。
 * 要点
改善版では、x-1によって、xがnで割り切れるかどうか（つまり余りがあるかないか）を考慮する必要がなくなります。 これは、x-1によって実際に求めたいアルファベットの位置に対応するようにxを調整しているためです。この結果、x / n の計算においては、直接アルファベットのインデックスを得ることができ、奇数か偶数か、または余りを考慮する必要がありません。

x-1の操作は、アルファベットの位置を0ベースで考えるためのものです。 x = 1でAを求めたい場合、x-1 = 0としてからnで割り、結果に'A'を加えることで、正確なアルファベットの文字を得ることができます。
 *
*/
/**改善版*/
int main(void) {
  int n,x,a;
  cin >> n >> x;
  a = x / n;
  cout << char('A' + a) << endl;
}
